# [Live Demo](https://guarded-eyrie-72660.herokuapp.com/)

> **Note:**
>
> For reasons described below, the app currently only functions with the provided links and only the time variable can be changed without the produced manifest file breaking. The app in its current state should therefore be regarded as proof-of-concept.

## Concept

A simple user-friendly web-app which accepts a link to a main .m3u8 manifest file, the link of a separate .m3u8 manifest file to be insterted in to the first and an insertion point, generating a link to a new .m3u8 manifest file incorporating the insertion ready for copy-pasting in to a video player.

## Pseudo-code

- Receive form content on `POST`
- Validate and sanitise form content
- Hand parameters to `HLSSpliceVod` to generate content of new manifest
- Format content for new manifest file
  - Insert absolute links to main content
- Write to new file in the cloud (Github)
- Return file URI to user

## Issues / Questions

_(As issues mostly arrive from questions I have yet to answer, they are presented together)_

### `${manifestUrl}/${relativeTsFilePath}` doesn't always find .ts files

I would assume that the file path of the .ts files of the main content in the manifest generated by `HLSSpliceVod` is relative to the manifest file path, which is to say using the file found at:

```
https://maitv-vod.lab.eyevinn.technology/stswe17-ozer.mp4/master.m3u8
```

The file references within the generated manifest such as:

```
#EXTINF:10.8800,
2000-00000.ts // this
```

Would refer to a file found at:

```
https://maitv-vod.lab.eyevinn.technology/stswe17-ozer.mp4/2000-00000.ts
```

But this fails. It can, however, found at:

<pre>
https://maitv-vod.lab.eyevinn.technology/stswe17-ozer.mp4/<b>2000</b>/2000-00000.ts
</pre>

Therefore, to demonstrate my concept, I currently have to use ugly string manipulation to insert `/2000/` between the permalink to the .mp4 file and the .ts file relative path, rendering the splicer useless for all other source manifests.

I couldn't find many active free HLS VOD test streams, but to use for example the following [parkour](https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8) link:

```
https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8
```

Which, when used as the main content source, generates a manifest with the file path:

```
../video/720-2400000/hls/segment_0.ts
```

And the .ts files can indeed be found at:

```
https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/../video/720-2400000/hls/segment_0.ts
// resolves to:
// https://bitdash-a.akamaihd.net/content/MI201109210084_1/video/720-2400000/hls/segment_0.ts
```

> Do the relative paths of the .ts files in the .m3u8 file resolve to the same directory as the .m3u8 file itself, and if so, why can't the .ts files be found for the link to the Streaming Tech Sweden talk without looking in folder '2000'?

### Streams with separately declared audio manifests lack audio

Going back to the parkour .m3u8, I notice that it contains a link to a separate audio manifest unlike the .m3u8 files provided by Eyevinn:

```
#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="audio",NAME="English stereo",LANGUAGE="en",AUTOSELECT=YES,URI="f08e80da-bf1d-4e3d-8899-f0f6155f6efa_audio_1_stereo_128000.m3u8"
```

If I pass this link as the first parameter in to `HLSSpliceVod`, no reference to the audio manifest is found in the output and the video loads without audio:

```
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-TARGETDURATION:11
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.0000,
https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/../video/720_2400000/hls/segment_0.ts
// etc.
```

> Is the lack of audio related to the omission of the audio manifest, and if so, is there an argument or method on `HLSSpliceVod` to catch separately declared audio manifests? Your article specifically mentions that '_The video player first downloads the master playlist/manifest that contains links to each individual media playlist._', so I'm sure I've missed something!

### Using some manifest files results in `this.playlist` on the `HLSSpliceVod` instantiation never being assigned

Using the content provided from the exercise brief as the main content in to which the ad must be inserted:

```
https://maitv-vod.lab.eyevinn.technology/VINN.mp4/master.m3u8
```

I get the following error:

```
    this.playlists[bw].set('playlistType', "VOD"); // Ensure playlist type is VOD
                       ^

TypeError: Cannot read property 'set' of undefined
    at HLSSpliceVod.getMediaManifest (/home/daoud/Documents/Eyevinn/hls-splice-daoud/node_modules/@eyevinn/hls-splice/index.js:244:24)
```

I can't grasp everything going on in the `HLSSpliceVod` library, but having a look I can see that when `load()` is called:

```js
// line 72
const mediaManifestUrl = url.resolve(baseUrl, streamItem.get("uri"));
// 'baseUrl' being the original URL passed to the class instantiation
mediaManifestPromises.push(
  this._loadMediaManifest(
    mediaManifestUrl,
    streamItem.get("bandwidth"),
    _injectMediaManifest
  )
);
```

Then, in `_loadMediaManifest` called above:

```js
// line 252
parser.on('m3u', m3u => {
this.duration = 0;
if (!this.playlists[bandwidth]) {
    this.playlists[bandwidth] = m3u;
}
// function continues
```

Not understanding what the `m3u` generated by the parser is, I can't trace the exact point at which `this.playlists` isn't being correctly assigned and is causing the `undefined` error when `getMediaManifests` attempts to call the `.set` method of `this.playlists[bw]`.

> How and when is `this.playlists` being incorrectly assigned using the VINN.mp4 manifest? How is the bandwith argument determined for ´getMediaManifest´, and does it need to be changed from the number in your example?
 
### Persistent Amazon S3 storage signing error

Understanding Heroku's ephemeral storage and the necessity of using external file hosting, I followed their suggestion and did all I could to set up Amazon S3 storage for the new .m3u8 file write. However, I kept getting the `SignatureDoesNotMatch` error. I tried to troubleshoot this, but it seems it could be any of a mismatch of regions (when I declared the same region for the region and endpoint params as the bucket), an invalid character in the keys (none was present in either of the keys I tried) or a mismatched timezone between the two ends of the request. In the interest of expedience I moved to using Github for such a simple operation, but in a production app a solution would have to be found. The original code for Amazon S3 is left commented out to show my current grasp of Amazon S3.

## Further questions

> - In your article on AWS Lamda functions, if I understand correctly, the source manifest is being spliced **in place**, which is to say that the source file is somehow being processed so that the relative .ts file paths in the newly generated manifest file will resolve relative to the _original_ URL; could you explain how this works in terms of what resultant URL is actually passed to the video player? I'm sorry, I've never used anything like AWS Lamda functions before!

> - Having not understood the above, is my web-app ultimately an incorrect solution/approach to the exercise? I imagine that even aiming for the current functionality, there is a better approach than declaring a permalink for every video segment in the source file (and certainly one better than achieving that by string splicing!)

## Imagined future functionality

- **Limiting the insertion point relative to the original video's length**

On paste of the original link, a request would be sent to determine the length of the video which would populate more extensive time selection inputs such as a slider, e.g.:

<pre>
                                        ___       ____
Time:  0s -------|^|----------- 3m15s  | 1 | min | 21 | secs  [ ] At start [ ] At end
                                        ¯¯¯       ¯¯¯¯
</pre>

- **Multiple video insertions possible**

- **Presentation, click link to copy etc.**

## Future code maintenance

- Fully unit test
- Refactor in TypeScript

## Conclusion

This was an enlightening project, teaching me a lot about manifest files, their purpose, the specific content of spliced manifest files, use of the `HSLSpliceVod` and server-side processing (this was my first ever Node JS app), learning about writing files to 3rd party services along the way.

Thank you for reading!
